# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2019 by ShabaniPy Authors, see AUTHORS for more details.
#
# Distributed under the terms of the MIT license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""Implementation  of the pseudo random number generator ran1

The C++ implementation can be found in:
A. Sawada, T. Koga, Universal modeling of weak antilocalization corrections in
quasi-two-dimensional electron systems using predetermined return orbitals.
Phys. Rev. E. 95, 023309 (2017).

We use an explicit state to avoid relying on a global variable.

"""
from collections import namedtuple

import numpy as np
from numba  import njit


Ran1State = namedtuple('Ran1State', ['seed', 'iy', 'iv'])


@njit(fastmath=True)
def seed_ran1(seed: int) -> Ran1State:
    """Create a new state based on a seed.

    """
    return ran1(Ran1State(seed, 0, np.empty(1)))[1]


@njit(fastmath=True)
def ran1(state: Ran1State) -> (float, Ran1State):
    """Ran1 implementation.

    Parameters
    ----------
    state : float
        State/seed of the random number generator.

    Returns
    -------
    value : float
        Random value generated by the call.
    state : float
        State to use for the next call.

    """
    IA = 16807
    IM = 2147483647
    IQ = 127773
    IR = 2836
    NTAB = 32
    NDIV = 1 + (IM-1) / NTAB
    EPS = 3.0e-16
    AM = 1.0 / IM
    RNMX = 1.0 - EPS

    seed, iy, iv = state
    # Initialize the generator
    if seed <= 0 or iy == 0:
        iv = np.empty(NTAB)
        if -seed < 1:
            seed = 1
        else:
            seed = -seed

        for j in range(NTAB + 7, -1, -1):
            k = int(seed / IQ)
            seed = IA*(seed - k*IQ) - IR*k

            if seed < 0:
                seed += IM
            if j < NTAB:
                iv[j] = seed

        iy = iv[0]

    k = int(seed/IQ)
    seed = IA*(seed - k*IQ) - IR*k
    if seed < 0:
        seed += IM
    j = int(iy /NDIV)
    iy = iv[j]
    iv[j] = seed
    temp = np.float64(np.float32(RNMX)) if AM*iy > RNMX else AM*iy
    return temp, Ran1State(seed, iy, iv)


if __name__ == '__main__':
    state = seed_ran1(-1000)
    for i in range(3):
        value, state = ran1(state)
        print(value)
